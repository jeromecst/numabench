diff --color -Nur stable-linux/fs/exec.c linux-6.5.7/fs/exec.c
--- stable-linux/fs/exec.c	2024-06-12 15:41:35.628024890 +0200
+++ linux-6.5.7/fs/exec.c	2024-06-12 16:17:00.319801160 +0200
@@ -1886,6 +1886,63 @@
 	return retval;
 }
 
+static int max_tab(int *tab, int len)
+{
+	int max = 0;
+	for (int i = 1; i < len; i++) {
+		if (tab[i] > tab[max])
+			max = i;
+	}
+	return max;
+}
+
+/*
+ * Check all the argument of exec
+ * if is a file check the number of page in pagecache
+ * Put in numa_preferred_nid the node with the more page in pagecache
+ */
+void mv_core_exec(struct user_arg_ptr argv)
+{
+	int tab[NR_CPUS] = { 0 };
+	for (int i = 1;; i++) {
+		// Get the argument
+		const char __user *arg = get_user_arg_ptr(argv, i);
+		if (arg == NULL)
+			break;
+		if (arg[0] == '-')
+			continue;
+		// Get struct path with dentry inside
+		struct path path;
+		int err = kern_path(arg, LOOKUP_FOLLOW, &path);
+		if (err)
+			continue;
+		// If file doesn't exist
+		if (path.dentry->d_inode == NULL) {
+			continue;
+		}
+
+		// If it's a file
+		struct address_space *mapping = path.dentry->d_inode->i_mapping;
+		// If no page in page-cache
+		if (xa_empty(&(mapping->i_pages)) || mapping->nrpages <= 0)
+			continue;
+
+		xa_lock(&mapping->i_pages);
+		XA_STATE(xas, &mapping->i_pages, 0);
+
+		struct folio *folio;
+		rcu_read_lock();
+		// Add the number of page in tab
+		xas_for_each(&xas, folio, ULONG_MAX)
+			tab[folio_nid(folio)] += folio_nr_pages(folio);
+
+		rcu_read_unlock();
+		xa_unlock(&mapping->i_pages);
+	}
+	current->numa_preferred_nid = max_tab(tab, NR_CPUS);
+}
+
 static int do_execveat_common(int fd, struct filename *filename,
 			      struct user_arg_ptr argv,
 			      struct user_arg_ptr envp, int flags)
@@ -1927,6 +1984,7 @@
 	if (retval < 0)
 		goto out_free;
 	bprm->argc = retval;
+	mv_core_exec(argv);
 
 	retval = count(envp, MAX_ARG_STRINGS);
 	if (retval < 0)
